name: Refresh Token, Compress, and Upload Images & Video Thumbnails

on:
  push:
    branches:
      - main

jobs:
  compress-media:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Set up Node.js environment
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      # Step 3: Install Dependencies (ImageMagick with HEIC support)
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip imagemagick libheif-dev libheif-examples ffmpeg jq
          # Verify HEIC support in ImageMagick
          convert -list format | grep HEIC || echo "HEIC format not supported by ImageMagick."

      # Step 4: Refresh Dropbox Access Token
      - name: Refresh Dropbox Access Token
        id: refresh_token
        env:
          CLIENT_ID: ${{ secrets.DROPBOX_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.DROPBOX_CLIENT_SECRET }}
          REFRESH_TOKEN: ${{ secrets.DROPBOX_REFRESH_TOKEN }}
        run: |
          set -e  # Exit on error
          echo "Refreshing Dropbox access token..."
          response=$(curl -s -X POST https://api.dropboxapi.com/oauth2/token \
            --data "grant_type=refresh_token&refresh_token=$REFRESH_TOKEN&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET" \
            -H "Content-Type: application/x-www-form-urlencoded")

          echo "Dropbox token response: $response"

          ACCESS_TOKEN=$(echo "$response" | jq -r '.access_token')
          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
            echo "Failed to retrieve access token."
            exit 1
          fi
          # Use GITHUB_OUTPUT to set the access_token output
          echo "access_token=$ACCESS_TOKEN" >> $GITHUB_OUTPUT

      # Step 5: List and Process All Image and Video Files
      - name: List and process all media files
        env:
          ACCESS_TOKEN: ${{ steps.refresh_token.outputs.access_token }}
        run: |
          set -e  # Exit on error
          # Removed set -x to prevent secrets from being printed
          mkdir -p downloaded_images compressed_images downloaded_video_thumbnails compressed_video_thumbnails
          echo "Listing all files in Dropbox and filtering images and videos..."

          # Initialize variables
          cursor=""
          has_more=true
          page=1  # To track the number of pages processed

          # Configure Git
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

          while [ "$has_more" = true ]; do
            echo "Processing page $page..."
            if [ -z "$cursor" ]; then
              # Initial call to list_folder
              response=$(curl -s -X POST https://api.dropboxapi.com/2/files/list_folder \
                --header "Authorization: Bearer $ACCESS_TOKEN" \
                --header "Content-Type: application/json" \
                --data '{
                  "path": "",
                  "recursive": true,
                  "include_media_info": true,
                  "include_deleted": false
                }')
            else
              # Subsequent calls to list_folder/continue
              response=$(curl -s -X POST https://api.dropboxapi.com/2/files/list_folder/continue \
                --header "Authorization: Bearer $ACCESS_TOKEN" \
                --header "Content-Type: application/json" \
                --data "{\"cursor\": \"$cursor\"}")
            fi

            # Log the response status
            echo "Received response for page $page."

            # Check for errors in the response
            error=$(echo "$response" | jq -r '.error // empty')
            if [ -n "$error" ]; then
              echo "Dropbox API error: $error"
              exit 1
            fi

            # Extract entries and cursor
            entries=$(echo "$response" | jq -c '.entries[]?')
            cursor=$(echo "$response" | jq -r '.cursor')
            has_more=$(echo "$response" | jq -r '.has_more')

            echo "Page $page: has_more=$has_more, cursor=$cursor"

            # Process each entry
            echo "$entries" | while read -r entry; do
              tag=$(echo "$entry" | jq -r '.[".tag"]')
              if [ "$tag" == "file" ]; then
                mime_type=$(echo "$entry" | jq -r '.media_info.metadata.mime_type // empty')
                echo "Found file with MIME type: $mime_type"
                if [[ "$mime_type" == image/* ]]; then
                  # Process Images
                  path=$(echo "$entry" | jq -r '.path_lower')
                  filename=$(basename "$path")
                  echo "Processing image: $filename at path: $path"

                  # Replace spaces with underscores and preserve folder structure
                  relative_path=$(dirname "$path" | sed 's|^/||') # Remove leading slash
                  target_dir="compressed_images/$relative_path"
                  mkdir -p "$target_dir"
                  sanitized_filename=$(echo "$filename" | tr ' ' '_')
                  compressed_image_path="$target_dir/$sanitized_filename"

                  if [ ! -f "$compressed_image_path" ]; then
                    echo "Generating temporary link for $path..."
                    temp_link_response=$(curl -s -X POST https://api.dropboxapi.com/2/files/get_temporary_link \
                      --header "Authorization: Bearer $ACCESS_TOKEN" \
                      --header "Content-Type: application/json" \
                      --data "{\"path\": \"$path\"}")

                    temp_link=$(echo "$temp_link_response" | jq -r '.link')
                    if [ "$temp_link" != "null" ] && [ -n "$temp_link" ]; then
                      echo "Downloading $filename from $temp_link"
                      downloaded_image="downloaded_images/$sanitized_filename"
                      curl -s -L "$temp_link" -o "$downloaded_image"
                      if [ ! -f "$downloaded_image" ]; then
                        echo "Failed to download $filename."
                        continue
                      fi

                      # Check if the file is HEIC
                      if [[ "$mime_type" == "image/heic" || "$mime_type" == "image/heif" ]]; then
                        echo "Converting HEIC to JPEG for $filename"
                        # Change extension to .jpg
                        converted_filename="${sanitized_filename%.*}.jpg"
                        converted_image="downloaded_images/$converted_filename"
                        convert "$downloaded_image" "$converted_image" || { echo "Failed to convert HEIC to JPEG for $filename"; continue; }
                        echo "Compressed JPEG: $converted_filename"
                        
                        # Compress the JPEG
                        mogrify -path "$target_dir" -resize 50% "$converted_image" || echo "Error compressing $converted_filename"

                        # Stage the compressed JPEG for commit
                        git add "$target_dir/$converted_filename" || echo "No matching files to add for $converted_filename"

                        # Remove the original and converted downloaded images to save space
                        rm "$downloaded_image" "$converted_image"
                      else
                        # Compress other image formats normally
                        echo "Compressing $filename..."
                        mogrify -path "$target_dir" -resize 50% "$downloaded_image" || echo "Error compressing $filename"

                        # Stage the compressed image for commit
                        git add "$compressed_image_path" || echo "No matching files to add for $compressed_image_path"

                        # Remove the original downloaded image to save space
                        rm "$downloaded_image"
                      fi
                    else
                      echo "Failed to get temporary link for $path"
                    fi
                  else
                    echo "$compressed_image_path is already compressed, skipping."
                  fi
                elif [[ "$mime_type" == video/* ]]; then
                  # Process Videos
                  path=$(echo "$entry" | jq -r '.path_lower')
                  video_filename=$(basename "$path")
                  echo "Processing video: $video_filename at path: $path"

                  # Define thumbnail filename
                  thumbnail_filename="${video_filename%.*}-video.jpg"  # Use the video name with -video suffix
                  thumbnail_filename=$(echo "$thumbnail_filename" | tr ' ' '_')  # Replace spaces with underscores
                  relative_path=$(dirname "$path" | sed 's|^/||') # Remove leading slash
                  target_dir="compressed_video_thumbnails/$relative_path"
                  mkdir -p "$target_dir"
                  compressed_thumbnail_path="$target_dir/$thumbnail_filename"

                  if [ ! -f "$compressed_thumbnail_path" ]; then
                    echo "Generating thumbnail for $path..."
                    
                    # Use get_thumbnail_v2 to get a high-quality thumbnail
                    thumbnail_response=$(curl -s -X POST https://content.dropboxapi.com/2/files/get_thumbnail_v2 \
                      --header "Authorization: Bearer $ACCESS_TOKEN" \
                      --header "Dropbox-API-Arg: {\"resource\": {\"path\": \"$path\"}, \"format\": \"jpeg\", \"size\": \"w1024h768\"}" \
                      --output "downloaded_video_thumbnails/$thumbnail_filename")

                    if [ -f "downloaded_video_thumbnails/$thumbnail_filename" ]; then
                      echo "Downloaded thumbnail: $thumbnail_filename"

                      # Compress the thumbnail
                      echo "Compressing thumbnail $thumbnail_filename..."
                      mogrify -path "$target_dir" -resize 50% "downloaded_video_thumbnails/$thumbnail_filename" || echo "Error compressing thumbnail $thumbnail_filename"

                      # Stage the compressed thumbnail for commit
                      git add "$compressed_thumbnail_path" || echo "No matching files to add for $compressed_thumbnail_path"

                      # Remove the original downloaded thumbnail to save space
                      rm "downloaded_video_thumbnails/$thumbnail_filename"
                    else
                      echo "Failed to get thumbnail for $path"
                    fi
                  else
                    echo "$compressed_thumbnail_path is already compressed, skipping."
                  fi
                else
                  echo "Skipping non-image and non-video file."
                fi
              fi
            done

            # Increment page counter
            page=$((page + 1))
          done

          echo "Completed listing and processing all media files."

          # Log Git status before committing
          echo "Staging completed. Current Git status:"
          git status

          # Commit and push all compressed images and thumbnails at once
          if ! git diff --cached --exit-code; then
            git commit -m "Add compressed images and video thumbnails from Dropbox"
            git push https://x-access-token:${{ secrets.ACCESS_TOKEN_2_WEBRENDHQ }}@github.com/kevinveragit/MacLellan-Frontend.git
          else
            echo "No new compressed media to commit."
          fi

      # Debug Step: Check if images and thumbnails were downloaded and compressed
      - name: List downloaded and compressed media
        run: |
          echo "Downloaded Images:"
          ls -R downloaded_images || echo "No downloaded images."
          echo "Compressed Images:"
          ls -R compressed_images || echo "No compressed images."
          echo "Downloaded Video Thumbnails:"
          ls -R downloaded_video_thumbnails || echo "No downloaded video thumbnails."
          echo "Compressed Video Thumbnails:"
          ls -R compressed_video_thumbnails || echo "No compressed video thumbnails."
