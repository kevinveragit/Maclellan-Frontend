<!DOCTYPE html><!--  This site was created in Webflow. https://webflow.com  --><!--  Last Published: Fri Sep 13 2024 01:42:22 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="65f0e0f6fbb9aca0de48af5d" data-wf-site="65ef6a9d933d09fb8c604750">
<head>
  <meta charset="utf-8">
  <title>Tina Coombs Family Site</title>
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="css/normalize.css" rel="stylesheet" type="text/css">
  <link href="css/webflow.css" rel="stylesheet" type="text/css">
  <link href="css/maclellan-family.webflow.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script>
  <script type="text/javascript">WebFont.load({  google: {    families: ["Changa One:400,400italic","Varela Round:400","Great Vibes:400","Exo:100,100italic,200,200italic,300,300italic,400,400italic,500,500italic,600,600italic,700,700italic,800,800italic,900,900italic","Montserrat:100,100italic,200,200italic,300,300italic,400,400italic,500,500italic,600,600italic,700,700italic,800,800italic,900,900italic"]  }});</script>
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="images/webclip.png" rel="apple-touch-icon"><!--  FIREBASE CODE  -->
  <!--  MADE BY WEBREND, KEVIN VERA  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dropbox.js/10.15.0/Dropbox-sdk.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script type="module">
// Import the functions you need from the SDKs you need
import { auth, db, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'https://maclellan-family-website.s3.us-east-2.amazonaws.com/firebase-init.js';
import { refreshDropboxAccessToken, createDropboxInstance, getDropboxInstance, accessToken } from 'https://maclellan-family-website.s3.us-east-2.amazonaws.com/dropbox-auth.js';
import { query, getDocs, collection, where } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
import { getUserCount, updateTotalFileCount } from 'https://maclellan-family-website.s3.us-east-2.amazonaws.com/usercount.js';
let cursor = null;
// Handle sign-up
async function handleSignUp(e) {
    e.preventDefault();
    e.stopPropagation();
    const name = document.getElementById('signup-name').value;
    const email = document.getElementById('signup-email').value;
    const password = document.getElementById('signup-password').value;
    console.log("Name is " + name);
    console.log("Email is " + email);
    try {
        const userCount = await getUserCount();
        if (userCount >= 6) {
            const errorText = document.getElementById('signup-error-message');
            errorText.innerHTML = "User limit reached. No more sign-ups allowed.";
            return;
        }
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        const user = userCredential.user;
        const uniqueKey = generateUniqueKey();
        console.log('User successfully created: ' + user.email);
        const folderPath = `/${name}`;
        console.log(`Creating folder in Dropbox at path: ${folderPath}`);
        const dbx = await getDropboxInstance();
        try {
            const createFolderResponse = await dbx.filesCreateFolderV2({ path: folderPath });
            console.log('Folder created in Dropbox for user:', createFolderResponse);
        } catch (dropboxError) {
            if (dropboxError.response) {
                const errorText = await dropboxError.response.text();
                console.error('Dropbox folder creation failed:', errorText);
            } else {
                console.error('Dropbox folder creation failed:', dropboxError);
            }
            throw dropboxError;
        }
        await setDoc(doc(db, "users", user.uid), {
            uid: user.uid,
            name: name,
            email: user.email,
            role: 'user',
            content: `This is the personalized content for ${email}. Your unique key is ${uniqueKey}.`,
            folderPath: folderPath
        });
        console.log('User document created with content and folder path.');
        location.reload();
    } catch (error) {
        const errorCode = error.code;
        const errorMessage = error.message;
        const errorText = document.getElementById('signup-error-message');
        console.log('Error during sign-up:', errorMessage);
        errorText.innerHTML = errorMessage;
    }
}
// Handle sign-in
async function handleSignIn(e) {
    e.preventDefault();
    e.stopPropagation();
    const email = document.getElementById('signin-email').value;
    const password = document.getElementById('signin-password').value;
    try {
        const userCredential = await signInWithEmailAndPassword(auth, email, password);
        const user = userCredential.user;
        console.log('User logged in: ' + user.email);
        const userDoc = await getDoc(doc(db, "users", user.uid));
        if (userDoc.exists()) {
            const userData = userDoc.data();
            console.log(`User document data: ${JSON.stringify(userData)}`);
            const dbx = await getDropboxInstance();
            console.log('Calling your folder from handleSignIn');
            await fetchAndDisplayUserDropboxFolder(userData.folderPath, dbx);
            await updateFileCount(userData.folderPath, dbx);
            await updateTotalFileCount(dbx);
            await displayAllUsers(); // Display all users for admin
            location.reload();
        } else {
            console.log("No such document!");
        }
    } catch (error) {
        const errorCode = error.code;
        const errorMessage = error.message;
        const errorText = document.getElementById('signin-error-message');
        console.log('Error during sign-in:', errorMessage);
        errorText.innerHTML = errorMessage;
    }
}
// Handle sign-out
function handleSignOut() {
  signOut(auth).then(() => {
    // Refreshes the current page
    window.location.reload();
    console.log('User signed out');
  }).catch((error) => {
    console.log(error.message);
  });
}
// removes an admin based on input
async function handleRemoveAdmin(e) {
    e.preventDefault();
    e.stopPropagation();
    const email = document.getElementById('remove-admin-email').value;
    try {
        const userQuery = query(collection(db, "users"), where("email", "==", email));
        const querySnapshot = await getDocs(userQuery);
        if (querySnapshot.empty) {
            const errorText = document.getElementById('remove-admin-error-message');
            errorText.innerHTML = "User not found.";
            return;
        }
        const userDoc = querySnapshot.docs[0];
        await updateDoc(userDoc.ref, {
            role: 'user'
        });
        console.log('User role updated to user: ' + email);
    } catch (error) {
        const errorMessage = error.message;
        const errorText = document.getElementById('remove-admin-error-message');
        console.log('Error during role removal:', errorMessage);
        errorText.innerHTML = errorMessage;
    }
}
// handle delete user
async function handleDeleteUser(e, uid) {
    e.preventDefault();
    e.stopPropagation();
    try {
        const userDocRef = doc(db, "users", uid);
        const userDoc = await getDoc(userDocRef);
        if (userDoc.exists()) {
            await deleteDoc(userDocRef);
            console.log('User document deleted from Firestore.');
        }
        const user = auth.currentUser;
        if (user && user.uid === uid) {
            await deleteUser(user);
        } else {
            const userCredential = await signInWithEmailAndPassword(auth, userDoc.data().email, "dummy-password");
            await deleteUser(userCredential.user);
        }
        await displayAllUsers(); // Refresh the user list after deletion
    } catch (error) {
        const errorMessage = error.message;
        console.log('Error during user deletion:', errorMessage);
    }
}
//handles assignment of admins
async function handleAssignAdmin(e) {
    e.preventDefault();
    e.stopPropagation();
    const email = document.getElementById('assign-admin-email').value;
    try {
        const userQuery = query(collection(db, "users"), where("email", "==", email));
        const querySnapshot = await getDocs(userQuery);
        if (querySnapshot.empty) {
            const errorText = document.getElementById('assign-admin-error-message');
            errorText.innerHTML = "User not found.";
            return;
        }
        const userDoc = querySnapshot.docs[0];
        await updateDoc(userDoc.ref, {
            role: 'admin'
        });
        console.log('User role updated to admin: ' + email);
    } catch (error) {
        const errorMessage = error.message;
        const errorText = document.getElementById('assign-admin-error-message');
        console.log('Error during role assignment:', errorMessage);
        errorText.innerHTML = errorMessage;
    }
}
// handles changing your email
async function handleChangeEmail(e) {
    e.preventDefault();
    e.stopPropagation();
    const currentPasswordForEmailChange = document.getElementById('current-password-email-change').value;
    const newEmail = document.getElementById('new-email').value;
    const user = auth.currentUser;
    const changeEmailMessage = document.getElementById('change-email-message');
    if (user) {
        const credential = EmailAuthProvider.credential(user.email, currentPasswordForEmailChange);
        try {
            console.log('Reauthenticating user...');
            await reauthenticateWithCredential(user, credential);
            console.log('Reauthentication successful. Updating email...');
            await updateEmail(user, newEmail);
            console.log('Email updated in Firebase Auth.');
            // Send verification email
            await sendEmailVerification(user);
            console.log('Verification email sent.');
            // Update the Firestore user document
            const userDocRef = doc(db, "users", user.uid);
            await updateDoc(userDocRef, {
                email: newEmail
            });
            console.log('Email updated in Firestore.');
            changeEmailMessage.style.color = "green";
            changeEmailMessage.innerHTML = "Email successfully updated. Please check your inbox to verify your new email.";
        } catch (error) {
            console.log('Error during email change:', error.message);
            changeEmailMessage.innerHTML = error.message;
        }
    } else {
        changeEmailMessage.innerHTML = "No user is currently signed in.";
    }
}
// changes pass based on current password
async function handleChangePassword(e) {
    e.preventDefault();
    e.stopPropagation();
    const currentPassword = document.getElementById('current-password').value;
    const newPassword = document.getElementById('new-password').value;
    const user = auth.currentUser;
    const changePasswordMessage = document.getElementById('change-password-message');
    if (user) {
        const credential = EmailAuthProvider.credential(user.email, currentPassword);
        try {
            await reauthenticateWithCredential(user, credential);
            await updatePassword(user, newPassword);
            changePasswordMessage.style.color = "green";
            changePasswordMessage.innerHTML = "Password successfully updated.";
        } catch (error) {
            console.log('Error during password change:', error.message);
            changePasswordMessage.innerHTML = error.message;
        }
    } else {
        changePasswordMessage.innerHTML = "No user is currently signed in.";
    }
}
// handles forgottne password and emails you
async function handleForgotPassword(e) {
    e.preventDefault();
    e.stopPropagation();
    const email = document.getElementById('forgot-password-email').value;
    const forgotPasswordMessage = document.getElementById('forgot-password-message');
    try {
        await sendPasswordResetEmail(auth, email);
        forgotPasswordMessage.style.color = "green";
        forgotPasswordMessage.innerHTML = "Password reset email sent successfully. Please check your inbox.";
    } catch (error) {
        console.log('Error during password reset:', error.message);
        forgotPasswordMessage.style.color = "red";
        forgotPasswordMessage.innerHTML = error.message;
    }
}
// gets all active users
async function displayAllUsers() {
    try {
        const usersDisplayed = document.getElementById('users-displayed');
        if (!usersDisplayed) {
            console.error('Element with id "users-displayed" not found.');
            return;
        }
        usersDisplayed.innerHTML = ''; // Clear existing content
        const querySnapshot = await getDocs(collection(db, "users"));
        querySnapshot.forEach((doc) => {
            const userData = doc.data();
            const userItem = document.createElement('div');
            userItem.className = 'user-item';
            userItem.innerText = userData.name;
            const removeButton = document.createElement('button');
            removeButton.innerText = 'REMOVE';
            removeButton.onclick = (e) => handleDeleteUser(e, userData.uid);
            userItem.appendChild(removeButton);
            usersDisplayed.appendChild(userItem);
        });
    } catch (error) {
        console.error('Error fetching users:', error);
    }
}
async function fetchAndDisplayUserDropboxFolder(folderPath, dbx) {
    try {
        console.log(`Fetching contents of folder: ${folderPath}`);
        const container = document.getElementById('user-pictures-container');
        if (!container) {
            console.error('Element with id "user-pictures-container" not found.');
            return;
        }
        container.innerHTML = ''; // Clear the container before fetching new content
        const response = await dbx.filesListFolder({ path: folderPath });
        const files = response.result.entries;
        console.log('Files in folder:', files);
        if (files.length === 0) {
            console.log(`No files found in folder: ${folderPath}`);
            container.innerHTML = '<p>No files found in your folder.</p>';
            return;
        }
        files.forEach(async (file) => {
            if (file['.tag'] === 'file') {
                const fileExtension = file.name.split('.').pop().toLowerCase();
                const tempLinkResponse = await dbx.filesGetTemporaryLink({ path: file.path_lower });
                let mediaElement;
                if (['jpg', 'jpeg', 'png', 'gif'].includes(fileExtension)) {
                    mediaElement = document.createElement('img');
                    mediaElement.src = tempLinkResponse.result.link;
                    mediaElement.style.maxWidth = '100%';
                } else if (['mp4', 'mov', 'avi', 'mkv'].includes(fileExtension)) {
                    mediaElement = document.createElement('video');
                    mediaElement.src = tempLinkResponse.result.link;
                    mediaElement.controls = true;
                    mediaElement.style.maxWidth = '100%';
                }
                if (mediaElement) {
                    const wrapper = document.createElement('div');
                    wrapper.style.position = 'relative';
                    wrapper.style.display = 'inline-block';
                    wrapper.appendChild(mediaElement);
                    const user = auth.currentUser;
                    const userDoc = await getDoc(doc(db, "users", user.uid));
                    if (userDoc.exists() && userDoc.data().role === 'admin') {
                        const deleteButton = document.createElement('button');
                        deleteButton.innerText = 'x';
                        deleteButton.id = 'admin-button';
                        deleteButton.style.position = 'absolute';
                        deleteButton.style.top = '8px';
                        deleteButton.style.right = '8px';
                        deleteButton.style.backgroundColor = 'white';
                        deleteButton.style.color = 'grey';
                        deleteButton.style.border = 'none';
                        deleteButton.style.borderRadius = '50%';
                        deleteButton.style.cursor = 'pointer';
                        deleteButton.onclick = () => handleDeleteFile(file.path_lower);
                        wrapper.appendChild(deleteButton);
                    }
                    container.appendChild(wrapper);
                }
            }
        });
    } catch (error) {
        console.error('Error fetching folder contents:', error);
    }
}
//update file count
async function updateFileCount(folderPath, dbx) {
    try {
        const response = await dbx.filesListFolder({ path: folderPath });
        const files = response.result.entries;
        const fileCountElement = document.getElementById('file-count');
        if (fileCountElement) {
            fileCountElement.innerText = files.length;
        } else {
            console.error('Element with id "file-count" not found.');
        }
    } catch (error) {
        console.error('Error fetching file count:', error);
        const fileCountElement = document.getElementById('file-count');
        if (fileCountElement) {
            fileCountElement.innerText = 'Error fetching file count';
        }
    }
}
// Listen for authentication state changes
onAuthStateChanged(auth, async (user) => {
    // DOM Elements
    let publicElements = document.querySelectorAll("[data-onlogin='hide']");
    let privateElements = document.querySelectorAll("[data-onlogin='show']");
    let adminContents = document.getElementById('adminContents');
    let adminAccessMessage = document.getElementById('adminAccessMessage');
    let uploadButtonAdmin = document.getElementById('uploadButtonAdmin');
    let usersDisplayed = document.getElementById('users-displayed');
    if (user) {
        const uid = user.uid;
        // Show or hide elements based on authentication state
        privateElements.forEach(element => {
            element.style.display = "flex";
        });
        publicElements.forEach(element => {
            element.style.display = "none";
        });
        const userQuery = query(collection(db, "users"), where("uid", "==", uid));
        const querySnapshot = await getDocs(userQuery);
        if (!querySnapshot.empty) {
            const userDoc = querySnapshot.docs[0];
            const userData = userDoc.data();
            console.log(`User document data: ${JSON.stringify(userData)}`);
            if (userData.role === 'admin') {
                if (adminContents) {
                    adminContents.style.display = "flex";
                }
                if (adminAccessMessage) {
                    adminAccessMessage.style.display = "none";
                }
                if (uploadButtonAdmin) {
                    uploadButtonAdmin.style.display = "block";
                }
                if (usersDisplayed) {
                    usersDisplayed.style.display = "block";
                }
                await displayAllUsers(); // Display all users for admin
            } else {
                if (adminContents) {
                    adminContents.style.display = "none";
                }
                if (adminAccessMessage) {
                    adminAccessMessage.style.display = "block";
                }
                if (uploadButtonAdmin) {
                    uploadButtonAdmin.style.display = "none";
                }
                if (usersDisplayed) {
                    usersDisplayed.style.display = "none";
                }
            }
            const dbx = await getDropboxInstance();
            console.log('Calling fetchAndDisplayUserDropboxFolder from onAuthStateChanged');
            await fetchAndDisplayUserDropboxFolder(userData.folderPath, dbx);
            await updateFileCount(userData.folderPath, dbx);
            await updateTotalFileCount(dbx);
        } else {
            if (adminContents) {
                adminContents.style.display = "none";
            }
            if (adminAccessMessage) {
                adminAccessMessage.style.display = "block";
            }
            if (userDashboard) {
                userDashboard.style.display = "none";
            }
            if (uploadButtonAdmin) {
                uploadButtonAdmin.style.display = "none";
            }
            if (usersDisplayed) {
                usersDisplayed.style.display = "none";
            }
        }
        console.log(`The current user's UID is ${uid}`);
    } else {
        // If no user is signed in, adjust UI elements accordingly
        publicElements.forEach(element => {
            element.style.display = "initial";
        });
        privateElements.forEach(element => {
            element.style.display = "none";
        });
        privateElementsFlex.forEach(element => {
            element.style.display = "none";
        });
        if (adminContents) {
            adminContents.style.display = "none";
        }
        if (adminAccessMessage) {
            adminAccessMessage.style.display = "block";
        }
        if (userDashboard) {
            userDashboard.style.display = "none";
        }
        if (uploadButtonAdmin) {
            uploadButtonAdmin.style.display = "none";
        }
        if (usersDisplayed) {
            usersDisplayed.style.display = "none";
        }
    }
});
// Function to search Dropbox files and append results
async function searchDropboxFiles(startIndex = 1) {
  await refreshDropboxAccessToken(); // Ensure the access token is fresh
  let searchResults = [];
  try {
    if (!cursor) {
      // Initial search request
      const response = await fetch('https://api.dropboxapi.com/2/files/search_v2', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          query: "family vacation",
          options: { max_results: 25, start: startIndex }
        })
      });
      if (response.ok) {
        const data = await response.json();
        searchResults = data.matches.map(match => match.metadata.metadata);
        cursor = data.cursor; // Save the cursor for the next request
      } else {
        console.error('Error searching Dropbox files:', response.statusText);
      }
    } else {
      // Continue from where we left off
      const response = await fetch('https://api.dropboxapi.com/2/files/search/continue_v2', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
            query: "family vacation", 
            cursor: cursor, 
            options: { max_results: 25, start: startIndex }
        })
      });
      if (response.ok) {
        const data = await response.json();
        searchResults = data.matches.map(match => match.metadata.metadata);
        cursor = data.cursor; // Update cursor for the next request
      } else {
        console.error('Error continuing search for Dropbox files:', response.statusText);
      }
    }
  } catch (error) {
    console.error('Error during search or continue search:', error);
  }
  return searchResults;
}
let startIndex = 1;
// Function to append search results to the DOM
async function appendResults(results) {
    const container = document.getElementById('search-results');
    for (const file of results) {
        if (startIndex >= 25) { // Stop appending after 25 elements
        appendLoadMoreButton();
        break;
        }
        if (file['.tag'] === 'file') {
            const fileExtension = file.name.split('.').pop().toLowerCase();
            let format = 'jpeg'; // Default format
            if (['png', 'heic'].includes(fileExtension)) {
                format = fileExtension; // Use png or heic if applicable
            }
            if (['jpg', 'jpeg', 'png', 'gif', 'mp4', 'mov', 'avi', 'mkv'].includes(fileExtension)) {
                try {
                const tempLinkResponse = await fetch('https://api.dropboxapi.com/2/files/get_temporary_link', {
                    method: 'POST',
                    headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: file.path_lower })
                });
                const thumbnailResponse = await fetch('https://content.dropboxapi.com/2/files/get_thumbnail', {
                    method: 'POST',
                    headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Dropbox-API-Arg': JSON.stringify({
                        path: file.path_lower,
                        format: format, // Choose your desired format
                        size: 'w640h480' // Choose your desired size (e.g., 'w128h128', 'w640h480')
                    })
                    }
                });
                if (!thumbnailResponse.ok) {
                    console.error('Error getting thumbnail:', thumbnailResponse.statusText);
                    continue;
                }
                if (tempLinkResponse.ok) {
                    const tempLinkData = await tempLinkResponse.json();
                    const previewData = await thumbnailResponse.blob();
                    let previewUrl = URL.createObjectURL(previewData);  // Use preview URL if available, otherwise temp link
                    // || tempLinkData.link
                    console.log('Thumbnail size:', previewData.size); // Log the size in bytes 
                    console.log(startIndex);
                    let mediaElement;
                    if (['jpg', 'jpeg', 'png', 'gif'].includes(fileExtension)) {
                    mediaElement = document.createElement('img');
                    // mediaElement.dataset.src = tempLinkData.link;
                    mediaElement.style.transition = 'all 0.3s ease-in-out';
                    mediaElement.src = previewUrl; // Use preview URL for initial loading
                    mediaElement.style.animation = 'fade-in 500ms forwards';
    				mediaElement.style.animationDelay = 'calc(0.1s * var(--))';
                    // mediaElement.setAttribute('data-src', tempLinkData.link); // Set temp link for lazy loading
                    // mediaElement.setAttribute('loading', 'lazy');
                    // mediaElement.style.maxWidth = '100%';
                    } else if (['mp4', 'mov', 'avi', 'mkv'].includes(fileExtension)) {
                    mediaElement = document.createElement('video');
                    // mediaElement.dataset.src = tempLinkData.link;
                    mediaElement.style.transition = 'all 0.3s ease-in-out';
                    mediaElement.src = previewUrl; // Use preview URL for initial loading
                    // mediaElement.setAttribute('data-src', tempLinkData.link); // Set temp link for lazy loading
                    // mediaElement.setAttribute('loading', 'lazy');
                    mediaElement.controls = true;
                    mediaElement.style.animation = 'fade-in 500ms forwards';
    				mediaElement.style.animationDelay = 'calc(0.1s * var(--))';
                    // mediaElement.style.maxWidth = '100%';
                    }
                    if (mediaElement) {
                    const wrapper = document.createElement('div');
                    wrapper.style.position = 'relative';
                    wrapper.style.display = 'inline-block';
                    wrapper.appendChild(mediaElement);
                    container.appendChild(wrapper);
                    // Increment the startIndex each time an element is added
                    startIndex++;
                    }
                } else {
                    console.error('Error getting temporary link:', tempLinkResponse.statusText);
                }
                } catch (error) {
                console.error('Error fetching temporary link:', error);
                }
            }
        }
    }
}
function appendLoadMoreButton() {
    const loadMoreButton = document.getElementById('load-more-button');
    loadMoreButton.style.display = 'flex';
    loadMoreButton.onclick = () => {
      startIndex = 0; // Reset the startIndex counter to 0 when the button is clicked
      loadMoreButton.style.display = 'none'; // Hide the button after clicking
      loadMoreFiles(); // Load more files
    };
  }
// Handle loading more files
async function loadMoreFiles() {
    const results = await searchDropboxFiles(startIndex);
    await appendResults(results);
}
// listeners
document.addEventListener('DOMContentLoaded', async function () {
    // remove admin button listener
    const removeAdminButton = document.getElementById('remove-admin-button');
    if (removeAdminButton) {
        removeAdminButton.addEventListener('click', handleRemoveAdmin);
    }
    //change password listener
    const changePasswordForm = document.getElementsByClassName('change-password-form');
    if (changePasswordForm.length > 0) {
        for (let i = 0; i < changePasswordForm.length; i++) {
            changePasswordForm[i].addEventListener('submit', handleChangePassword, true);
        }
    }
    // forgot password form listsneer
    const forgotPasswordForm = document.getElementById('forgot-password-form');
    if (forgotPasswordForm) {
        forgotPasswordForm.addEventListener('submit', handleForgotPassword, true);
    }
    // upload button listener
    const uploadButton = document.getElementById('uploadButton');
    if (uploadButton) {
        uploadButton.addEventListener('click', uploadImage);
    }
    // assign admin button listener
    const assignAdminButton = document.getElementById('assign-admin-button');
    if (assignAdminButton) {
        assignAdminButton.addEventListener('click', handleAssignAdmin);
    }
    // change email listener
    const changeEmailForm = document.getElementById('change-email-form');
    if (changeEmailForm) {
        changeEmailForm.addEventListener('submit', handleChangeEmail, true);
    }
})
// Initialize by loading the first set of files
loadMoreFiles();
// Add "Load More" button in a wrapper dynamically
const loadMoreWrapper = document.getElementById('load-more-wrapper');
const loadMoreButton = document.createElement('button');
loadMoreButton.id = 'load-more-button';
loadMoreButton.innerText = 'Load More';
loadMoreButton.style.display = 'none';
loadMoreButton.addEventListener('click', loadMoreFiles);
loadMoreWrapper.appendChild(loadMoreButton);
// Identify auth action forms
let signUpForm = document.getElementById('wf-form-signup-form');
let signInForm = document.getElementById('wf-form-signin-form');
let signOutButton = document.getElementById('signout-button');
// Assign event listeners if the elements exist
if (signUpForm) signUpForm.addEventListener('submit', handleSignUp, true);
if (signInForm) signInForm.addEventListener('submit', handleSignIn, true);
if (signOutButton) signOutButton.addEventListener('click', handleSignOut);
</script>
</head>
<body>
  <div class="w-users-userformpagewrap">
    <div class="w-users-userresetpasswordformwrapper">
      <div tabindex="-1" class="w-users-userformsuccessstate w-form-success">
        <div class="w-users-userformheader"><img src="https://d3e54v103j8qbb.cloudfront.net/img/email-72.67fa6be437.svg" loading="lazy" alt="">
          <h2>Password Reset Email Sent</h2>
        </div>
        <p>If we found an account associated with that email address, we&#x27;ve sent a link to reset your password.</p>
      </div>
      <form method="post" data-wf-user-form-type="resetPassword">
        <div class="w-users-userformheader">
          <h2>Reset Password</h2>
        </div><label for="wf-reset-password-email">Email</label><input maxlength="256" placeholder="" name="Email" id="wf-reset-password-email" aria-describedby="wf-reset-password-paragraph" class="w-input" type="email" autocomplete="username" required="" data-wf-user-form-input-type="email"><input type="submit" data-wait="Please wait..." class="w-users-userformbutton w-button" value="Reset Password">
      </form>
      <div style="display:none" data-wf-user-form-error="true" class="w-users-userformerrorstate w-form-fail">
        <div class="user-form-error-msg" wf-reset-pw-form-general-error-error="There was an error resetting your password. Please try again, or contact us if you continue to have problems.">There was an error resetting your password. Please try again, or contact us if you continue to have problems.</div>
      </div>
    </div>
  </div>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=65ef6a9d933d09fb8c604750" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="js/webflow.js" type="text/javascript"></script>
  <!--  Carousel for family  -->
  <script>
        const leftArrow = document.getElementById('left-arrow');
        const rightArrow = document.getElementById('right-arrow');
        const years = document.querySelector('.years');
        let index = 0;
        function showSlide(newIndex) {
            const items = document.querySelectorAll('.year-item');
            if (newIndex < 0) {
                index = items.length - 1;
            } else if (newIndex >= items.length) {
                index = 0;
            } else {
                index = newIndex;
            }
            years.style.transform = `translateX(-${index * 100}%)`;
        }
        leftArrow.addEventListener('click', () => {
            showSlide(index - 1);
        });
        rightArrow.addEventListener('click', () => {
            showSlide(index + 1);
        });
        setInterval(() => {
            showSlide(index + 1);
        }, 4000);
    </script>
  <script>
        // This script prints a custom message to the browser console
        (function() {
            console.log('%cCreated by WebRend and Kevin Vera', 'color: green; font-size: 20px; font-weight: bold;');
        })();
    </script>
  <!--  SCROLLBAR CSS  -->
  <style>
/* For WebKit browsers (Chrome, Safari) */
::-webkit-scrollbar {
  width: 12px; /* Adjust the width of the scrollbar */
}
::-webkit-scrollbar-track {
  background: #000; /* Black background for the track */
}
::-webkit-scrollbar-thumb {
  background: #333; /* Dark grey for the thumb */
  border-radius: 10px; /* Rounded corners for the thumb */
}
::-webkit-scrollbar-thumb:hover {
  background: #555; /* Slightly lighter grey when hovered */
}
/* For Firefox */
html {
  scrollbar-width: thin; /* Make the scrollbar thin */
  scrollbar-color: #333 #000; /* Thumb color, Track color */
}
/* For Internet Explorer and Edge */
* {
  scrollbar-color: #333 #000; /* Thumb color, Track color */
  scrollbar-width: thin; /* Make the scrollbar thin */
}
</style>
</body>
</html>